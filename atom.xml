<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Eayne.github.io</id>
    <title>myy blog</title>
    <updated>2021-10-02T03:05:30.314Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Eayne.github.io"/>
    <link rel="self" href="https://Eayne.github.io/atom.xml"/>
    <subtitle>我的过去常常在追赶着我。</subtitle>
    <logo>https://Eayne.github.io/images/avatar.png</logo>
    <icon>https://Eayne.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, myy blog</rights>
    <entry>
        <title type="html"><![CDATA[线程同步]]></title>
        <id>https://Eayne.github.io/post/xian-cheng-tong-bu/</id>
        <link href="https://Eayne.github.io/post/xian-cheng-tong-bu/">
        </link>
        <updated>2021-10-02T02:11:21.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程安全的对象生命期管理]]></title>
        <id>https://Eayne.github.io/post/xian-cheng-an-quan-de-dui-xiang-sheng-ming-qi-guan-li/</id>
        <link href="https://Eayne.github.io/post/xian-cheng-an-quan-de-dui-xiang-sheng-ming-qi-guan-li/">
        </link>
        <updated>2021-10-02T02:11:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>核心问题是对象在析构时，其他线程调用这个对象的成员函数。或者在调用成员函数期间被其他线程析构</li>
</ul>
<h2 id="对象构造线程安全">对象构造线程安全</h2>
<ul>
<li>不要在构造函数中注册任何回调，或者在构造函数中将this指针传给跨线程的对象。</li>
<li><code>muduo</code>中是一个事件驱动的网络库，涉及到很多回调注册的操作。这些注册都是放在一个单独的函数类似<code>start</code> 中进行的，而不是在构造函数中进行的。</li>
</ul>
<h2 id="对象析构线程安全">对象析构线程安全</h2>
<ul>
<li>使用<code>mutex</code>保护析构没有用。<br>
比如线程A要析构这个对象上了锁，线程B此时调用这个对象的某个方法被锁阻塞，这样该对象被两个线程同时访问，还是不能安全地析构。<br>
安全析构意味着只有一个线程可以访问这个对象来析构。</li>
<li>解决方法是使用<code>weak_ptr</code>和<code>shared_ptr</code>
<ol>
<li><code>shared_ptr</code>是线程安全的，保证当最后一个指向对象的<code>shared_ptr</code>析构或者<code>reset</code>时，对象会被销毁<br>
（去除<code>shared_ptr</code>指向对象的计数：reset或者析构）</li>
<li><code>weak_ptr</code>可以被提升（<code>lock()</code>）为<code>shared_ptr</code>，如果指向的对象已经为空了，那么提升失败，会返回一个空的<code>shared_ptr</code></li>
</ol>
</li>
<li>场景1：A对象包含B对象，但是不保证B对象的生命周期（如<code>Observable</code>更新时调用各个<code>Observer</code>对象的<code>update</code>函数）<br>
此时<code>Observable</code>只需要持有<code>Observer</code>对象的<code>weak_ptr</code>，并且在<code>update</code>时先提升为<code>shared_ptr</code>，并检查非空后调用<code>update()</code></li>
<li>场景2：B对象反过来需要包含A对象，但是也不保证A对象的生命周期（比如<code>Observer</code>需要<code>Observable</code>的<code>unregister</code>函数）<br>
此时<code>Observer</code>也是包含<code>Observable</code>的<code>weak_ptr</code>，并使用上述类似的方式提升、调用。<br>
注意，这里需要<code>public enabled_shared_from_this</code>的继承+<code>weak_ptr&lt;Observable&gt;(shared_from_this())</code>（弱回调）</li>
<li>场景3：B对象反过来需要包含A对象，且强制要求A在B存活时也存活。<br>
类似上面，只不过是B不是包含<code>weak_ptr</code>，而是包含<code>shared_ptr</code></li>
<li>场景4：B对象反过来包含A对象，但是不保证A对象的生命周期。但是如果有需求的话，可以保证A在B存活时也存活。<br>
（<code>muduo</code>中的<code>TcpConnection</code>和<code>Channel</code>关系，即<code>TcpConnecting</code>以<code>unique_ptr</code>包含<code>Channel</code>，而<code>Channel</code>以弱指针包含<code>TcpConnecting</code>，当通过Channel调用TcpConnection的callback时，可能会导致TcpConenction在Callback中被析构从而导致Channel析构，此时Channel要在调用Callback前保证TcpConnection的生命周期）<br>
B包含A的<code>weak_ptr</code>，当需要保证A存活时，先在函数中将<code>weak_ptr</code>提升为<code>shared_ptr</code>，然后调用如TcpConnection的Callback，这样即使callback有意消除TcpConenction，也会被当前的函数先持有，等到该函数执行完毕后，<code>shared_ptr</code>析构，才让<code>TcpConnection</code>和<code>Channel</code>析构。</li>
<li>注意不要使用两个<code>shared_ptr</code>互相持有，这样会导致循环引用。</li>
<li><code>enabled_shared_from_this</code>的对象，不能使用栈内存分配，而是使用堆内存分配（<code>new</code>）</li>
</ul>
<h2 id="死锁">死锁</h2>
<ul>
<li>如果一次性要锁住多个对象，为了避免死锁，常用的一个规则是加锁是按照顺序加锁</li>
<li>比如使用<code>std::lock</code>可以原子地锁住两个对象</li>
<li>也可以根据被锁对象的地址，从小到大的顺序进行加锁。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Muduo I/O多路复用]]></title>
        <id>https://Eayne.github.io/post/muduo-io-duo-lu-fu-yong/</id>
        <link href="https://Eayne.github.io/post/muduo-io-duo-lu-fu-yong/">
        </link>
        <updated>2021-10-01T08:10:38.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>non-blocking网络库的核心是event loop，这依赖于I/O multiplexing</li>
</ul>
<ol>
<li>non-blocking应该使用I/O multiplexing而不是轮询，后者费CPU</li>
<li>IO multiplexing不应该和blocking IO使用，后者的read/write/accept/connect会阻塞线程，从而影响IO多路复用中的其他事件处理。</li>
</ol>
<h2 id="level-trigger和edge-trigger">level trigger和edge trigger</h2>
<ul>
<li>level trigger（LT）：水平触发，满足条件就触发，比如读事件就是内核缓冲区有数据，写事件是内核缓冲区可写</li>
<li>edge trigger（ET）：边缘触发，状态变化才触发，比如读事件中先读了50字节，剩下的数据不读的话下次IO事件如果没有新的可读数据，则不会提醒（在LT中是会再次触发的）</li>
<li>select和poll都属于LT，而epoll支持ET+LT</li>
<li>使用LT而不是用ET的理由：
<ol>
<li>LT编程更容易，不容易漏掉事件。</li>
<li>使用ET的话，在IO事件发生时进行读写需要一直重复（<code>read,write</code>）直到EAGAIN出现才算完成，而LT就不需要这么多次的系统调用。</li>
</ol>
</li>
<li>在使用LT时也要注意busy-loop问题，会导致CPU 100%利用率
<ol>
<li>读时一次性将内核缓冲区<code>read</code>完</li>
<li><code>write</code>完以后及早关闭可写事件的注册。</li>
</ol>
</li>
</ul>
<h2 id="epoll和poll-select对比">epoll和poll、select对比</h2>
<ul>
<li>epoll适合文件描述符多、活动文件描述符比例小的情况。</li>
<li>poll、select适合文件描述符少、活动文件描述符比例高的情况。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Muduo 多线程]]></title>
        <id>https://Eayne.github.io/post/muduo-duo-xian-cheng/</id>
        <link href="https://Eayne.github.io/post/muduo-duo-xian-cheng/">
        </link>
        <updated>2021-10-01T07:21:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="线程安全">线程安全</h2>
<p>muduo中解决线程安全的三种方式：</p>
<ol>
<li>使用<code>mutex</code>加锁</li>
<li>将对象作为内部对象，不暴露给其他对象或线程访问。因此也就不需要加锁</li>
<li>将函数执行装入到事件循环的任务执行队列中，即让对应的线程执行，而不是当前线程执行。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Muduo C/S设计]]></title>
        <id>https://Eayne.github.io/post/muduo-cs-she-ji/</id>
        <link href="https://Eayne.github.io/post/muduo-cs-she-ji/">
        </link>
        <updated>2021-10-01T06:51:43.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Muduo 定时器]]></title>
        <id>https://Eayne.github.io/post/muduo-ding-shi-qi/</id>
        <link href="https://Eayne.github.io/post/muduo-ding-shi-qi/">
        </link>
        <updated>2021-10-01T06:51:14.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++编译链接模型]]></title>
        <id>https://Eayne.github.io/post/cbian-yi-lian-jie-mo-xing/</id>
        <link href="https://Eayne.github.io/post/cbian-yi-lian-jie-mo-xing/">
        </link>
        <updated>2021-10-01T00:58:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="编译链接模型">编译链接模型</h2>
<ul>
<li>将多个.cpp源文件分别编译成.o文件，然后再将用到的目标文件、静态库与动态库链接成对应的可执行文件。</li>
</ul>
<h2 id="前向编译">前向编译</h2>
<h3 id="前向编译是什么">前向编译是什么</h3>
<pre><code class="language-c++">//b.h
class A;
class B{
    A* ptr;
};
</code></pre>
<ul>
<li>此时在b.h文件中不需要<code>#include &quot;a.h&quot;</code>就可以通过编译。</li>
</ul>
<h3 id="前向编译合理的原因">前向编译合理的原因</h3>
<ul>
<li>编译器在执行parse时，只需要知道对应的声明即可，不需要知道实现。<br>
如函数（参数个数、类型、返回值类型），因此函数声明通常放在头文件中，这样<code>include</code>这个头文件的源文件都可以使用这个函数。<br>
另外，类的声明也是类似的。比如在编译期间，B类中只需要<code>A*</code>这种指针类型，但是不需要知道A的具体定义</li>
<li>然而，前向声明部分的内容需要在某个源文件中定义。否则会在链接期间出现错误。<br>
然后<code>#include &quot;b.h&quot;</code>的文件都需要和定义的源文件进行链接（无论该定义是.o文件还是库文件）</li>
<li>b.cpp文件还是需要<code>#include &quot;A.h&quot;</code>的，因为在b.cpp文件中是需要用到A类的定义的。</li>
</ul>
<h3 id="前向编译的好处">前向编译的好处</h3>
<ol>
<li>可以用来减少编译期依赖。<br>
因为如果其他文件需要<code>#include &quot;b.h&quot;</code>，这些文件不需要将a.h头文件的内容一起包含进去。这样如果a.h发生改动的话，需要重新编译的源文件会减少。</li>
<li>可以避免将内部类暴露给外部。<br>
利用前向声明不<code>include</code>某个内部类，而是将这个内部类的include放在对应的源文件实现中，这样其他包含这个.h文件的外部文件就不会看到内部类了。</li>
<li>有时前向编译是必须的。<br>
比如两个类相互指涉的情况，即A类包含B类对象，B类也包含A类对象，这样无论先定义A类还是B类都会错误，解决办法是使用前向声明其中一个类即可。</li>
</ol>
<h3 id="前向编译使用情况即编译期间不需要完整定义的">前向编译使用情况（即编译期间不需要完整定义的）</h3>
<ul>
<li>定义或声明为<code>A*,A&amp;</code>，包括函数参数、返回类型、局部变量、类成员变量等。或者如<code>unique_ptr&lt;A&gt;,vector&lt;A&gt;</code>这种A作为模版类型的。</li>
<li>声明以Foo为参数或返回类型的函数。<br>
但是，如果该函数被定义或者调用，那么就需要知道Foo的定义（因为要用到拷贝构造函数或者析构函数），此时不能使用前向声明。<br>
类似的，如果Foo为成员变量类型的话，也不可以使用前向声明。</li>
<li>当要访问到Foo类的成员，需要知道Foo的大小（sizeof）等情况不能使用前向声明，因为此时需要知道这个类的定义。</li>
</ul>
<h3 id="简化编译模型时的一些坑">简化编译模型时的一些坑</h3>
<ul>
<li>注意如果在.h文件中，某个类包含类似<code>Foo Buffer</code>这样的成员对象，就不能使用前向声明<code>class Foo;</code>了。但是类似<code>Foo&amp; Buffer,Foo* Buufer</code>是可以使用前向声明的。</li>
<li>注意include的传递性。<br>
如果<code>#include a.h</code>，且a.h包含了<code>b.h</code>，那么当前文件就不需要再include<code>b.h</code>了</li>
<li>注意形如<code>shared_ptr&lt;T&gt;,unique_ptr&lt;T&gt;</code>的类成员对象的前向声明。<br>
如果在包含了智能指针对象的类中，使用了默认的析构函数（不定义析构函数，或者在.h文件中写<code>~A()=default</code>)，且使用了前向声明就会出错。<br>
报错内容为<code>sizeof(assert(T_))..</code>，这是因为默认析构函数，编译器会在.h文件中补充该析构函数，然而该析构函数用到了前向声明类T的sizeof，此时在不知道T定义的情况下，无法通过编译。<br>
解决办法是将默认析构函数移到.cpp文件中。</li>
<li>注意namespace的问题。</li>
</ul>
<pre><code class="language-c++">namespace A{
class B;
class C{

};
}
</code></pre>
<p>这里的B实际是<code>A::B</code>的意思，如果要使用如某个POSIX库的struct的前向声明，这个struct要放到A的作用域以外才行。</p>
<ul>
<li>注意不要重载&amp;符号。</li>
</ul>
<pre><code class="language-c++">class Foo;
void bar(Foo &amp;foo)
{
    Foo* p = &amp;foo;
}
</code></pre>
<p>原因有两个，1是<code>&amp;foo</code>的操作失去了原意，即不一定是取指针操作了（取决于重载函数的内容）。<br>
2是没办法使用前向声明了，因为此时<code>&amp;foo</code>操作需要知道foo对&amp;操作的定义了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Muduo Buffer]]></title>
        <id>https://Eayne.github.io/post/muduo-buffer/</id>
        <link href="https://Eayne.github.io/post/muduo-buffer/">
        </link>
        <updated>2021-09-24T14:01:14.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Muduo的Buffer是应用层（用户态）Buffer，即从应用层Output Buffer写入内核缓冲区，以及从内核缓冲区写入到应用层Input Buffer</li>
</ul>
<h2 id="需要buffer原因">需要Buffer原因</h2>
<ul>
<li>Muduo是非阻塞网络库。核心想法是将<code>read,write</code>等系统调用为应用层封装好，应用层不用管底层的发送细节、错误、处理等。</li>
<li>对于每个TCP连接，都分配一个Input Buffer和Output Buffer。</li>
<li>Output Buffer：在调用<code>write</code>系统调用时，只是将数据写入到内核缓冲区后就返回。
<ul>
<li>发送数据：<br>
在非阻塞网络编程中，可能出现只写入了部分数据，剩下部分数据没有成功写入（因为内核缓冲区满了），因此需要Output Buffer将未写入的数据缓冲起来，注册I/O复用的POLLOUT事件，等待下次在I/O复用返回内核缓冲区可写时写入。<br>
（另外，在Output Buffer的内容全部<code>write</code>清空后，要及时撤销POLLOUT事件，否则每次循环时，可写事件都通知网络库，而网络库又没有内容写，就进入了busy loop）</li>
<li>主动关闭连接（shutdown）：<br>
如果程序要主动关闭连接，此时Output Buffer还有剩余，则应该先将Output Buffer的内容发送完毕，然后才调用<code>socket</code>层<code>shutdown write</code>。</li>
</ul>
</li>
<li>Input Buffer：TCP接收到的消息不一定构成一条完整的信息或者一次性构成多个消息，此时需要Input Buffer将包暂存起来，供用户进行TCP分包操作。
<ul>
<li>读取数据：<br>
在I/O复用中，当<code>socket</code>内核缓冲区变得可读时，一次性将内核缓冲区当内容拷贝到InputBuffer中。<br>
（注意，如果没有一次性读取完，会反复触发<code>POLLIN</code>事件，因为muduo采用的是<code>level trigger</code>而不是edge  trigger）<br>
然后调用用户提供的接收消息Callback函数，由用户自行去进行TCP分包。</li>
</ul>
</li>
</ul>
<h2 id="buffer设计">Buffer设计</h2>
<ul>
<li>Buffer是动态连续内存空间，即<code>vector&lt;char&gt;</code>。</li>
<li>Buffer初始内存大小规划问题：
<ol>
<li>如果初始内存过小，会导致需要多次系统调用进行<code>read</code>。</li>
<li>如果初始内存过大，虽然减小了系统调用次数，但是连接数量一多就会导致内存占用过大、使用效率低。</li>
</ol>
</li>
<li>readv + 临时栈上空间解决该问题：
<ul>
<li>readv可以在调用read时传入iovec数组，一个iovec类似一个内存缓冲区。readv在读入到前一个iovec满了以后，会继续读到下一个iovec。</li>
</ul>
<ol>
<li>在读取到Input Buffer时，先申请一个很大的栈上空间<code>char extrabuf[65536]</code>，然后将input buffer + extrabuf作为iovec传入readv。</li>
<li>readv先写入到Input Buffer，如果Input Buffer内存不够用，就写入到extrabuf中，再将extrabuf的内容拷贝到Input Buffer中（先扩容Input Buffer）。</li>
</ol>
<ul>
<li>好处是一开始Input Buffer可以设定的比较小，而readv因为extrabuf比较大通常一次就可以读取完，然后再将Input Buffer扩容到指定大小。</li>
</ul>
</li>
<li>Buffer数据结构：
<ol>
<li>其实是一个<code>vector&lt;char&gt;</code>加两个读写指针。写的时候增加写指针，读的时候增加读指针。<br>
注意这里的指针没有用<code>void*</code>类型，而是<code>int</code>类型，这是因为当对Buffer进行扩容时，<code>void*</code>就失效了。</li>
<li>当读指针赶上了写指针，说明读完Buffer的内容了，此时将指针归位到Buffer开始处。</li>
<li>当往Buffer写数据，而可用空间不够时，会先判断如果将Buffer当前数据移动到Buffer头部（即腾挪）的话剩余空间是否足够。如果不足够，才会进行扩容+拷贝Buffer当前内容的操作。</li>
<li>Buffer不会缩容，避免反复分配内存。比如经常收发10kB的数据，就可以让缓冲区自适应到10kB大小</li>
<li>Prepend操作：<code>vector&lt;char&gt;</code>的头部固定8个字节被保留下来，这样可以很方便的在数据前面添加字节。<br>
比如如果不知道一个消息的长度，可以先将这个消息append到Buffer中，最终统计完长度在将长度Prepend到Buffer中</li>
</ol>
</li>
</ul>
<h2 id="其他的buffer设计">其他的Buffer设计</h2>
<ul>
<li>类似libevent、linux的sk_buff都是分段连续的buffer，使用链表将数据块链接到一起</li>
<li>好处是zero-copy，即扩容时不再需要像vector一样的resize、copy操作</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Muduo Reactor]]></title>
        <id>https://Eayne.github.io/post/muduo-reactor/</id>
        <link href="https://Eayne.github.io/post/muduo-reactor/">
        </link>
        <updated>2021-09-24T14:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[muduo 构建]]></title>
        <id>https://Eayne.github.io/post/muduo-gou-jian/</id>
        <link href="https://Eayne.github.io/post/muduo-gou-jian/">
        </link>
        <updated>2021-09-22T09:29:01.000Z</updated>
        <content type="html"><![CDATA[<p>C++项目的构建、布局等</p>
<h2 id="源代码布局">源代码布局</h2>
<h2 id="生成文件布局">生成文件布局</h2>
<h2 id="构建过程">构建过程</h2>
<h2 id="测试">测试</h2>
]]></content>
    </entry>
</feed>